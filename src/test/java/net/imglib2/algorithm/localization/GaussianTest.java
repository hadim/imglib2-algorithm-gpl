package net.imglib2.algorithm.localization;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Dummy test using precalculated value. Paranoid FTW.
 * @author Jean-Yves Tinevez
 *
 */
public class GaussianTest {

	private final Gaussian g = new Gaussian();

	private static final double params[] = new double[] {  10, 3, -5, 0.1 };
	private static final double TOLERANCE = 1e-14; // set by MATLAB display of floats

	private static final double[] X = new double[] { 
		3.159867420596879,
		1.103038032858990,
		3.822981242846749,
		4.353955611368059,
		4.715465090410710,
		1.617681749234017,
		3.898755246333701,
		3.201266700630153,
		4.652139996939846,
		4.072314159851837,
		4.795776851970151,
		2.736124264150838,
		2.705597087697465,
		5.015546810610877,
		-1.247310924831500,
		1.990827188971980,
		0.458811100382680,
		2.234830394584703,
		4.297358524097241,
		4.651454298483516
	};
	private static final double[] Y = new double[] { 
		-7.029887285360275,
		-5.942139825366333,
		-4.725950251739899,
		-5.583726751507147,
		-4.396362889477987,
		-4.200138114088396,
		-6.859923117880259,
		-5.353660531858464,
		-9.264189198323070,
		-2.709276578963052,
		-6.258181521988311,
		-7.407699948004437,
		-5.507889366845624,
		-7.857293729264195,
		-5.041715235403201,
		-6.121329993056369,
		-0.644442581631692,
		-2.723069225340810,
		-9.993773006369004,
		-4.117346136544783
	};
	private static final double[] val = new double[] { 
		6.606044707457830,
		6.385155719134934,
		9.275207256277604,
		8.046134752868623,
		7.184064212548737,
		7.748713384659125,
		6.526544259110939,
		9.835779311970722,
		1.235279776544316,
		5.274363180947717,
		6.182987497882451,
		5.561790832815880,
		9.661245992344252,
		2.944471819756201,
		1.646161259002138,
		7.964578487801539,
		0.786417818703992,
		5.615862962883823,
		0.698021269288002,
		7.042387024842610
	};
	private static final double [] dgdx0_val = new double[] { 
		0.211218265545790,
		-2.422479510694376,
		1.526664319086505,
		2.178821859694005,
		2.464802272779253,
		-2.142237586313792,
		1.173153178661011,
		0.395922970049333,
		0.408171025247956,
		1.131154864626283,
		2.220653164943630,
		-0.293524329729682,
		-0.568859791323468,
		1.186944157048643,
		-1.398351739878832,
		-1.607527212237595,
		-0.399687246270370,
		-0.859417529475239,
		0.181116768742393,
		2.326036064752174
	};
	private static final double [] dgdy0_val = new double[] {
		-2.681905231638037,
		-1.203141898832525,
		0.508373642728628,
		-0.939348820296152,
		0.867313552613504,
		1.239580100248388,
		-2.427774109477824,
		-0.695705388542808,
		-1.053493336009441,
		2.416421453930375,
		-1.555864124104088,
		-2.678224699796469,
		-0.981368821998308,
		-1.682644173316905,
		-0.013734000886181,
		-1.786184148084681,
		0.685057592838639,
		2.557386241291784,
		-0.697151954488371,
		1.243198023084844
	};
	private static final double[] dgdb_val = new double[] { 
		-2.738866124769502e+01,
		-2.864439698211295e+01,
		-6.978678837717236e+00,
		-1.749175559253816e+01,
		-2.375912450266991e+01,
		-1.976373494880797e+01,
		-2.784925382641803e+01,
		-1.628648238071843e+00,
		-2.583325290160445e+01,
		-3.374153298969259e+01,
		-2.972678520766158e+01,
		-3.262907709470605e+01,
		-3.329503844520988e+00,
		-3.600075077556969e+01,
		-2.969903769312246e+01,
		-1.812587306973521e+01,
		-1.999744237019375e+01,
		-3.240295803701407e+01,
		-1.858195997723156e+01,
		-2.469327897839193e+01
	};


	@Test
	public final void testVal() {
		double[] pos = new double[2];
		for (int i = 0; i < X.length; i++) {
			pos[0] = X[i];
			pos[1] = Y[i];
			assertEquals("Bad accuracy for x=" + pos[0]+", y="+pos[1]+" in gaussian value.", val[i], g.val(pos, params), TOLERANCE);
		}
	}

	@Test
	public final void testGradient() {
		double[] pos = new double[2];
		// dG/dA
		for (int i = 0; i < X.length; i++) {
			pos[0] = X[i];
			pos[1] = Y[i];
			assertEquals("Bad accuracy for x=" + pos[0]+", y="+pos[1]+" in dG/dA value.", val[i] / params[0], g.grad(pos, params, 0), TOLERANCE);
		}
		// dG/dx0
		for (int i = 0; i < X.length; i++) {
			pos[0] = X[i];
			pos[1] = Y[i];
			assertEquals("Bad accuracy for x=" + pos[0]+", y="+pos[1]+" in dG/dx0 value.", dgdx0_val[i], g.grad(pos, params, 1), TOLERANCE);
		}
		// dG/dy0
		for (int i = 0; i < X.length; i++) {
			pos[0] = X[i];
			pos[1] = Y[i];
			assertEquals("Bad accuracy for x=" + pos[0]+", y="+pos[1]+" in dG/dy0 value.", dgdy0_val[i], g.grad(pos, params, 2), TOLERANCE);
		}
		// dG/db
		for (int i = 0; i < X.length; i++) {
			pos[0] = X[i];
			pos[1] = Y[i];
			assertEquals("Bad accuracy for x=" + pos[0]+", y="+pos[1]+" in dG/db value.", dgdb_val[i], g.grad(pos, params, 3), 1e2*TOLERANCE);
		}

	}

}
